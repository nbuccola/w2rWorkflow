---
output:
  word_document: default
  html_document: default
---
-----
title: "CE-QUAL-W2 temperature modeling of Willamette Reservoirs"
author: Norman Buccola
output: html_document
----

```{r global_options, include = FALSE, results = "hide"} 
# Norman Buccola, USACE, 2023-07-26
knitr::opts_chunk$set(
  fig.width = 8,
  fig.height = 4,
  fig.path = "Figs",
  #root.dir = "media/removable/Elements/ColumbiaEIS/",
  #root.dir = "F:/ColumbiaEIS/",
  include = TRUE,
  echo = FALSE,
  warning = FALSE,
  message = FALSE
)

library(dplyr)
library(tidyr)
library(readr)
library(purrr)
library(w2r)

c2f = function(x) {
  (x * 9 / 5) + 32
}
f2c = function(x) {
  (x - 32) * 5 / 9
}

# Set working directory
wd = "C:/projects/WillametteDisposition2023/WQ"
DataDir = file.path(wd, "RES-SIM")
projFldr = "DcmPnstck"
# Where to get RES-SIM data
RefDataDir = file.path(wd,RefData)
#funcDir <- 'C:/Users/g2echnb9/Documents/R/w2r/R'
verDir = ""
scenarios = data.frame(Baseline = NA, DcmPnstck = NA, RcnPnstck = NA, StationService = NA)

years = c('2011','2015','2016')
# Read in RES-SIM to W2 codes
RessimCodes = read_csv(file.path(DataDir, "WillW2OutputNmsSeg.csv"))
# Load outlets at each dam
source(file.path(DataDir, "QGT_elvsFrom_w2_con_2021-11-01.r"))

# Load the Rule Curves
source(file.path(DataDir, "WVWQfunctions_2023-07-19.r"))

RuleCurveDir = file.path(RefDataDir, "rule_curves")
rcs = ReadRuleCurves(RuleCurveDir) |> 
   expand_grid(tibble(Year = factor(c(2011, 2015, 2016))))  |>
   expand_grid(tibble(Alt = names(scenarios))) |>
   mutate(Site = factor(Site))

elvVolCurvPath = file.path(RefDataDir, "elv_vol_curves")
```

Water Balance steps:
1. Run the W2 models a first time with QDT set to OFF. 
2. Run the following code chunk to calculate the missing flow needed (QDT) to meet the operational lake levels and close the water balance for each reservoir. Use the WillW2_HCR-LOP_IRRM_2020_watbalSwitch.csv file to control which reservoir, year, and scenario needs a new QDT (re-)written. 
3. Re-Run W2 model with QDT set to ON and repeat step 2. 
4. Repeat steps 2 and 3 as needed. In the MF Willamette, only one iteration was needed.


```{r RunWaterBalance, echo = FALSE, include = FALSE, results = "hide"}
rm(wbFits)
# True will change QDT to "OFF" in the control file
firstRun = FALSE


wbFits = read_csv(file.path(wd, "WillW2_HydDisp_watbalSwitch.csv")) |>
  mutate(Year = factor(round(Year))) |>
  # turn wide table into long table
  pivot_longer(!all_of(c("RESSIMCode", "Year")),
    names_to = "Scenario", values_to = "Flag") |>
  # drop rows that we are not investigating
  filter(!is.na(Flag)) |>
  # attach WQ model codes
  left_join(RessimCodes, by = "RESSIMCode") |>
  mutate(
    # get working directory for each model run
    path = file.path(wd, Scenario, W2name, paste0(W2name, Year)),
    pathExists = file.exists(path),
    # identify qdt value for every run
    qdt = if_else(firstRun & Flag, "OFF", "ON"),
    # get path to elevation-volume curve for every run
    # should error if you get more than 1 curve per model
    elvVolCrvFl = map_chr(RESSIMCode, function(x)
      dir(elvVolCurvPath, full.names = TRUE,
        pattern = sprintf("%s_elev_curve_fromPreProcessor.csv", x))
    )
  )

# walk trough model 
wbFits |>
  select(path, qdt, seg = SegmentOutput, wb) |>
  pwalk(modifyW2con)

wbSummary = wbFits |>
  mutate(Result = pmap(
    list(path = path, seg = SegmentOutput, wb = wb, write.files = Flag,
      elvVolCrvFl =elvVolCrvFl, RESSIMCode = ReachName),
    function(...)
      readW2ConInOut(..., wd = wd)$watbal$fit
  )) |>
  hoist(Result, "N", "ME", "MAE")


plt = ggplot(wbSummary) +
  aes(x = RESSIMCode, y = MAE) +
  geom_point(size = 5, shape = 21, fill = "lightblue") +
  ggtitle('Water Balance') +
  facet_grid(c("Year", "Scenario")) +
  scale_x_discrete(NULL) +
  theme_bw(18)

ggsave(plt, file.path(wd, projFldr, verDir, "WaterBalanceSummary.png"),
  width = 9,height = 6)
```
